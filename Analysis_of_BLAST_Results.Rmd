---
title: "Analysis of BLAST Results"
author: "Maggie Chen"
date: "October 12, 2018"
output: github_document
---

# Introduction
This is a further reslut analysis from the research that intend to investigate whether mcirobe community on human skins
will match the microbe community on objects touched by the same individual. Micbrobe commnunity refers to the microorgnaisms composition in a shared living space. In this research, our main focus is on the bactieral community composition. Bacteria is a type of biological cell, and it is a member of unicelluar microorgnisms group. Bacteria has various shape and length, as well as different effect to human bodies. The original research of matching microbe community compostion also has intended to serve as an additional tool of forensic examination. Forensic investigation denoting the application of scientific methods and techniques to the investigation of crime. Thus, it is possible to match the microbe community on suspect's hand with the object the suspect has touched as one form of forensic envidence. 

# Methods


## Sample origin and sequencing

Add about a paragraph here.

## Computational
Using the data gained from the sequencing in the research. Fristly, we run a quality check on all the sequences, and this is call QuickCheck, whcih also generates an QC report with quality evaluations of the sequence based on different parameters. Then, based on the quality score of the sequence, we trimed out the low quality portions in each sequence. So far, we have only wokring on the sequence in the formate of '.fasta'. However, the final goal for this sequence processing is to use BLAST to identify different species, which only accept '.fastq' file. Thus, we use 'biowak' to convert all the trimmed sequences into '.fastq' formate. Lastly, we input all the coverted sequences into BLAST, to identify all the species in the sample we took. Overall, to process this analysis faster, the work was done on an remote machine with better cabability than personal laptop. To analyze the BLAST result, as an primary interpreation, code are wirtten to simplify and summarize the species names found. To further analyze the BLAST result, R is used to generate different graph. 

And another paragraph or two here.

# Results

```{r load-libraries, message = FALSE}
# Be sure to install these packages before running this script
# They can be installed either with the install.packages() function
# or with the 'Packages' pane in RStudio

# load packages
library("dplyr")
library("tidyr")
library("knitr")
library("ggplot2")
```

```{r make-read-in-data-function}
# Output format from BLAST is as detailed on:
# https://www.ncbi.nlm.nih.gov/books/NBK279675/
# In this case, we used: '10 sscinames std'
# 10 means csv format
# sscinames means unique Subject Scientific Name(s), separated by a ';'
# std means the standard set of result columns, which are:
# 'qseqid sseqid pident length mismatch
# gapopen qstart qend sstart send evalue bitscore',


# this function takes as input a quoted path to a BLAST result file
# and produces as output a dataframe with proper column headers
# and the 'qseqid' column split into sample and seq number
read_blast_output <- function(filename) {
  data_in <- read.csv(filename,
                      header = FALSE, # files don't have column names in them
                      col.names = c("sscinames", # unique Subject Sci Name(s)
                                    "qseqid",    # Query Seq-id
                                    "sseqid",    # Subject Seq-id
                                    "pident",    # Percntge of identical matches
                                    "length",    # Alignment length
                                    "mismatch",  # Number of mismatches
                                    "gapopen",   # Number of gap openings
                                    "qstart",    # Start of alignment in query
                                    "qend",      # End of alignment in query
                                    "sstart",    # Start of alignment in subj
                                    "send",      # End of alignment in subject
                                    "evalue",    # Expect value
                                    "bitscore"))  # Bit score

  # Next we want to split the query sequence ID into
  # Sample and Number components so we can group by sample
  # They originally look like "ERR1942280.1"
  # and we want to split that into two columns: "ERR1942280" and "1"
  # we can use the separate() function from the tidyr library to do this
  # Note that we have to double escape the period for this to work
  # the syntax is
  # separate(column_to_separate,
  # c("New_column_name_1", "New_column_name_2"),
  # "seperator")
  data_in <- data_in %>%
    separate(qseqid, c("sample_name", "sample_number"), "\\.")
}
```

```{r read-in-BLAST-data}
# this makes a vector of all the BLAST output file names, including
# the name(s) of the directories they are in
files_to_read_in <- list.files(path = "output/blast",
                               full.names = TRUE)

# We need to create an empty matrix with the right number of columns
# so that we can rbind() each dataset on to it
joined_blast_data <- matrix(nrow = 0,
                            ncol = 14)

# now we loop over each of the files in the list and append them
# to the bottom of the 'joined_blast_data' object
# we do this with the rbind() function and the function we
# made earlier to read in the files, read_blast_output()
for (filename in files_to_read_in) {
  joined_blast_data <- rbind(joined_blast_data,
                             read_blast_output(filename))
}
```

```{r read-in-metadata-and-join}
# Next we want to read in the metadata file so we can add that in too
# This is not a csv file, so we have to use a slightly different syntax
# here the `sep = "\t"` tells the function that the data are tab-delimited
# and the `stringsAsFactors = FALSE` tells it not to assume that things are
# categorical variables
metadata_in <- read.table(paste0("data/metadata/",
                                 "fierer_forensic_hand_mouse_SraRunTable.txt"),
                          sep = "\t",
                          header = TRUE,
                          stringsAsFactors = FALSE)

# Finally we use the left_join() function from dplyr to merge or 'join' the
# combined data and metadata into one big table, so it's easier to work with
# in R the `by = c("Run_s" = "sample_name")` syntax tells R which columns
# to match up when joining the datasets together
joined_blast_data_metadata <- metadata_in %>%
  left_join(joined_blast_data,
            by = c("Run_s" = "sample_name"))
```

```{r show-levels}
levels(factor(joined_blast_data_metadata$env_material_s))
```

```{r group-by-summarize}
# group by anonyamized name and calculate mean percent identity
joined_blast_data_metadata %>%
  group_by(sscinames) %>%
  summarize(mean_pident = mean(pident),
            sd_pident = sd(pident)) %>%
  filter(mean_pident > 85) %>%
  filter(mean_pident < 87) %>%
  select(sscinames) %>%
  distinct() %>%
  pull() -> target_pident_spp
  
joined_blast_data_metadata %>%
  filter(sscinames %in% target_pident_spp) %>%
  group_by(sscinames) %>%
  tally() %>%
  arrange(desc(n)) %>%
  filter(n > 3)
**Figure1** This will be the name of the figure in markdown
```




```{r histogram-male}
# Here we're using the dplyr piping syntax to select a subset of rows matching a
# criteria we specify (using the filter) function, and then pull out a column
# from the data to make a histogram.
joined_blast_data_metadata %>%
   filter(grepl("M", host_subject_id_s)) %>%
  ggplot(aes(x = pident)) +
    geom_histogram() +
    ggtitle("Male Percent Identity") +
    xlab("Percent") + 
  facet_grid(env_material_s ~ .)
```
```{r histogram-female}
# Here we're using the dplyr piping syntax to select a subset of rows matching a
# criteria we specify (using the filter) function, and then pull out a column
# from the data to make a histogram.
joined_blast_data_metadata %>%
   filter(grepl("F", host_subject_id_s)) %>%
  ggplot(aes(x = pident)) +
    geom_histogram() +
    ggtitle("Female Percent Identity") +
    xlab("Percent") +
    facet_grid(env_material_s ~ .)
```


```{r counting-rows}
# Count number of each species found and the corrolation with host
# Count the number of rows and group by different variables
joined_blast_data_metadata %>%
  mutate(sex_all_samples = substring(anonymized_name_s, 1, 1)) %>%
  group_by(sscinames, sex_all_samples, env_material_s) %>%
  tally() %>%
  arrange(desc(n)) %>%
  filter(n > 155) %>%
  ggplot(aes(x = sscinames, 
             y = n, 
             fill = sex_all_samples)) + 
  geom_col(position = position_dodge()) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   hjust = 1)) +
   ggtitle("") +
  xlab("species name") +
  ylab("number found") +
  facet_grid(env_material_s ~ .)
```



Don't forget to report what your figures show in words, here in the Results section.


```{r summary-table}
# Finally, we'd like to be able to make a summary table of the counts of
# sequences for each subject for both sample types. To do that we can use the
# table() function. We add the kable() function as well (from the tidyr package)
# in order to format the table nicely when the document is knitted
kable(table(joined_blast_data_metadata$host_subject_id_s,
            joined_blast_data_metadata$sample_type_s))
```

# Discussion

Add 2-3 paragraphs here interpreting your results and considering future directions one might take in analyzing these data.






